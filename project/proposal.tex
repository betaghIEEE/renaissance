\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{doublespace}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parskip = 0.2in
\parindent = 0.0in

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}

\title{Proposal: MPI, Distributed Objects, Rendezvous, and Distributed Tasks and their use in Scientific Computing Part 1}
\author{Daniel Beatty}
\begin{document}
\maketitle

\section {Feasibility Study}
The three items that are the heart of using xGrid for both integrated Grid and general applications in my dissertation, and are suitable for the Spring semester 2005.    
\begin{itemize}
\item xGrid
\item Scientific Computing on the Wavelet Representation of the SDSS
\item Wavelet Fits
\item Rendezvous, Distributed Objects, Directory Services, NSThreads, and Distributed Tasks.
\end{itemize}
\newpage
Issues of database relation optimization for the most part are going to be ignored.  The distributable piece of this puzzle is the jocfits (Java-Objective C FITS) object is to be defined as an object containing either libraries or proxies to libraries for processing the image and its data.   All other services will be either advertised objects(services), temporary objects generated by distributed tasks, or solely contained in the distributed task.  

%Rendezvous and Directory Services both represent lookup services, but they do not necessarily serve the same purpose.   Rendezvous is a zero-configuration and used for advertising services and configuring on the fly.  Directory Services are for general system configuration lookup, user information and a general hierarchical database.

%xGrid and Zillion are twin projects that distributed objects via NSPorts mainly.  

\subsection {Evolutionary Direction}
There exist an Application and Object Paradox whose nature submitted jobs such as numerical simulations.  One example is in MPI programming.  %The basic idea is set an army of program drones that talk with each other to accomplish a task.  
MPI uses a batch engine to launch many copies of same program which communicate with each other and use that communication to branch in paths to solve the problem the program was designed for.  
However, the what is the application.  In many respects, the MPI batch engine could be seen as the actual application since it sets the work in motion.   

Now consider the average application.  Every bit of work is set in motion by the user operating on the application and the application calls any method necessary to fulfill the users wish.  In MPI the environment is provide by the batch system.  For general applications, the environment is provided by the operating system which generally has a much more sophisticated process manager.  

If the desire is to maximize computational power, then a model needs to add a more techni-color spectrum to the idea of computational spectrum.  %Up until now, the idea computing hardware was either server or desktop.   This black and white picture has been portrayed with commodity machine and super-computer and very little gray area in the middle.    
To provide a technicolor federated scheme the federation must be able to discover its limits for each genre.  
The consequences to maximized computation with data includes:
\begin{itemize}\item Discovery Services 
\item Look Up services 
\item Secure access to the data
\item Confidence that proper services are being called.
\item Accessible common file system
\item Platform issues:
\begin{itemize}\item Platform Dependent Code
\item Non-platform dependent code such as JVM, .net, and intepreted languages.  \end{itemize}\end{itemize}

\subsection {SDSS Wavelet Application}
This feasibility study uses the problems encountered by the Sloan Digital Sky Survey to show the need of this scheme.   How does this scheme derive the use of wavelets?  How does this scheme work?   In fact, the application of wavelets to the SDSS data releases could be a topic in and of itself.  However, there is a common need.   

All of the SDSS data can be reduced to a collection of FITS files and the meta-data derived from it.  These FITS files can be viewed in terms of objects where the data comes from the files, and the operations contained in the object make it compatible with conventional and wavelet numerical methods.   Such an object can act as a proxy, and deliver the information as the transportable object itself.   

%The concept of using wavelets in this object make sense for making the object compact and easier to send.  
What is the point of using wavelets in these FITS objects?  First a matrix in a wavelet domain tends to be more sparse and easier to compact.  The wavelet domain also allows for feature detection,  image enhancement,  and noise reduction a much simpler operation.   Can these operations be handled by  these objects?  Can these operations be handled concurrently?  What message handling is in order?  These are questions for the feasibility study.  %Combined with the capacity to distributed these objects cleanly is concept worth pursuing.  This commonality comes in the form of objects that are brokered for purpose performing the operations concurrently.  



\subsection {Currently Available Distribution Schemes}
\subsubsection {Darwin and Distributed Objects}
OSX is a product of NeXTStep with the Mach micro-kernel.  As such it also has NSPorts.  One feature that is also present is another service registration scheme called Rendezvous.    Rendezvous is Apple's implementation of Zeroconf DNS which allows services to declare the name, type, port, etc.  

OSX uses NSPorts to provide distributed objects (DO(s)) and uses the run loop and or thread  to achieve a non-blocking solution.  Such DO are called via normal message passing routines associated with Objective C and NS Objects.  This mechanism provides a sort of proxy for which there are two classes"  NSDistributedObject and NSProxy.  

An NSConnection object has two instances of NSPort: one receives data and the other sends data.   An NSPort is a superclass to all other ports.  NSMachPort uses Mach messaging and is typically used solely on the machine itself.  NSSocketPorts use socket to go between machines.  

There are addition identifier/ modifier types applied to distributed objects: functions, methods and members alike.  These key words are as follows:
\begin{itemize}
\item oneway void ( client does not wait for a response.
\item in (A receiver is going to read the value but not change it.)
\item out ( A value is changed by the receiver by not read)
\item inout (receiver is to both read and write  the value).
\item bycopy (argument is archived before sent and de-archived in the receiver's process space)
\item byref (the argument is represented by proxy).   
\end{itemize}


Each connection can have a delegate.  Each time the connection spawns a new ``child'' connection, the ``child'' will have its delegate outlet set to point to its parent delegate. The connection monitor is a class for logging delegates and their connections.  

\subsubsection {Distributed Tasks}
Of course, there is nothing wrong with calling distributed tasks either.  An example was provided by O'Reilly's articles and written by Drew McCormack May 11, 2004 \cite {mccormack}. This analysis examines the crucial parts.

Apply Filters is the method that calls Distributed Task.  There are many nuggets of value in addition to the calls for:
\begin{itemize}
\item Add Sub Task with Identifier .  This call includes
\begin{enumerate}
\item The identifier
\item Launch path
\item Working Directory
\item Output Directory
\item Standard Input 
\item Standard Output
\end{enumerate}

\item Launch
\end{itemize}

The methods of how ``Photo Industry'' provides these values are somewhat interesting.  
\begin{itemize}
\item The first section of Apply Filters acquires the time.   
\item Next initiates local instances of the file manager.  
\item The output directory is fed into Apply Filters and is not interesting.  
\item The temporary directory segment is interesting.  
\begin{enumerate}
\item It uses the processes own information (supplied by NS (OSX) which identifies the process in all of its details.  The way this is used to access programs is with in the application itself.  
\item The temporary directory of functions which acquires the temporary directory as specified by the OS.  (Any where NS applies). 
\end{enumerate}
\item The next section claims to produce standard input for the filters which are actually programs and the parameters to those programs.  The means for this is the typical array/ dictionary scheme of Objective-C.  
\item The next segment produces input and temporary directories for the input data (the photos).  Features of these production(s) is the production of directories for the sub-tasks.  Thus a scheme for dividing the work judiciously is being applied.  
\end{itemize}
The question of the thread oriented submission becomes an issue.

Also, the feeding of data structures becomes an issue for the parent application:
\begin{itemize}
\item The manner the sub-tasks are divided up as a list of files (input).   Items copied into these directories into these directories are the data (photos) and the programs to work on them.
\item These structures include message forwarding which is the purpose of a NeXTStep delegate.  
\item ``A delegate is an object directed to carry out an action by another object.'' page 456 \cite {Kochan}
\item Once the sub-tasks and its data are determined, the sub job is copied out of the bundle (app), and the executable (script), then the sub-task queue is loaded.  
\item The rest of the methods are delegate methods.

\end{itemize}

\subsubsection {Devise xGrid client from Source}
One thing to be said about the distributed tasks devised by Drew McCormack is that it is a client of a client.  Of course, xGrid has three basic components by design: client, agent and controller.  Since xGrid's agent and client are open source, a good clean examination of these components may be in order to devise an xGrid API that makes any application simply a client of the xGrid system.  Some of these clients could broker xGrid's services to Federated systems like SORCER, Condor, Globus, and the like.  


 \end{document} 